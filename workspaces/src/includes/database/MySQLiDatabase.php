<?php

/**
 *    _, __,  _, _ __, _  _, _, _
 *   / \ |_) (_  | | \ | /_\ |\ |
 *   \ / |_) , ) | |_/ | | | | \|
 *    ~  ~    ~  ~ ~   ~ ~ ~ ~  ~
 *
 * Database implementation for MySQLi extension class
 *
 * @package     ObsidianWorkspaces
 * @subpackage  Keruald
 * @author      SÃ©bastien Santoro aka Dereckson <dereckson@espace-win.org>
 * @license     http://www.opensource.org/licenses/bsd-license.php BSD
 * @filesource
 *
 */

class MySQLiDatabase extends Database {
    /**
     * @var mysqli Represents a connection between PHP and a MySQL database.
     */
    private $db;

    /**
     * Initializes a new instance of the database abstraction class, for MySQL engine
     *
     * @param string $host The host of the MySQL server [optional, default: localhost]
     * @param string $username The username used to connect [optional, default: root]
     * @param string $password The password used to connect [optional, default: empty]
     * @param string $database The database to select [optional]
     */
    public function __construct($host = 'localhost', $username = 'root', $password = '', $database = '') {
        $this->db = new mysqli($host, $username, $password, $database);

        if ($this->db->connect_error) {
            $this->onCantConnectToHost();
        }
    }

    /**
     * Loads a new instance of the MySQLDatabase object
     *
     * @param Context $context The application context
     * @return MySQLDatabase The MySQLDatabase instance
     */
    public static function load (Context $context) {
        if (!array_key_exists('sql', $context->config)) {
            throw new InvalidArgumentException("To load a MySQL database, you need to add in your configuration a parameter block like:

    'sql' => [
        'engine' => 'MySQLi',
        'host' => 'localhost',
        'username' => 'obsidian',
        'password' => 'somePassword',
        'database' => 'obsidian'
    ]"
            );
        }

        $config = $context->config['sql'];
        return new MySQLiDatabase(
            $config['host'],
            $config['username'],
            $config['password'],
            $config['database']
        );
    }

    /**
     * Executes a query
     *
     * @param string $query The query to execute
     * @param int $resultType The result type (MYSQLI_ASSOC, MYSQLI_NUM, MYSQLI_BOTH)
     * @return DatabaseResult The query result
     */
    public function query ($query, $resultType = MYSQLI_BOTH) {
        $result = $this->db->query($query);
        if ($result) {
            if ($result === TRUE) {
                return new EmptyDatabaseResult();
            }
            return new MySQLiDatabaseResult($result, $resultType);
        }
        $this->onQueryError($query);
    }

    /**
     * Fetches a row of the result
     *
     * @param DatabaseResult $result The query result
     * @return array An associative array with the databae result
     */
    public function fetchRow (DatabaseResult $result) {
        return $result->fetchRow();
    }

    /**
     * Retrieves the id generated by the last statement
     *
     * @return int The last id generated
     */
    public function nextId () {
        return $this->db->insert_id;
    }

    /**
     * Escapes the expression
     *
     * @param $expression The expression to escape
     * @return string The escaped expression
     */
    public function escape ($expression) {
        return $this->db->real_escape_string($expression);
    }

    ///
    /// Events
    ///

    /**
     * Called on connect failure
     */
    protected function onCantConnectToHost () {
        $ex = new RuntimeException("Can't connect to SQL server: " . $this->db->connect_error);
        Events::callOrThrow($this->cantConnectToHostEvents, $this, $ex);
    }

    /**
     * Called on query error
     *
     * @param string $query The query executed when the error occured
     */
    protected function onQueryError ($query) {
        $ex = new DatabaseException(
            $query,
            $this->db->error,
            $this->db->errno
        );
        Events::callOrThrow($this->queryErrorEvents, [$this, $query, $ex], $ex);
    }
}
